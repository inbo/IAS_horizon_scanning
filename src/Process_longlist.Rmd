---
title: "Untitled"
author: "Soria Delva"
date: "2024-09-18"
output: html_document
---
This document describes how we arrived at a shortlist of species for the Horizon Scanning workshop, starting from a longlist of 7949 taxa.

# Setup
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Load libraries.
```{r Load libraries}
library(googlesheets4)
library(googledrive)
library(readxl)
library(dplyr)
library(rgbif)
library(progress)
library(sf)
library(rnaturalearth)
library(terra)
```

#Import data

```{r Read in data}
longlist <- read_excel("data/input/Species_long_list_Ana.xlsx")
```


#Process data

##Match initial dataset with the GBIF backbone

Match data.
```{r Match scientific names with GBIF backbone}
# Match taxa names with the GBIF backbone, retrieve taxon keys from GBIF when a match is found
# Initialize progress bar
pb <- progress_bar$new(
 format = "\033[35m Processing [:bar] :current/:total (:percent) in :elapsed \033[0m",
  total = nrow(longlist),
  width = 60,
  clear = FALSE                  
)

mapped_taxa<-data.frame()
for (i in 1:nrow(longlist)){
  pb$tick()
  nubkey_row<-longlist[i,]
  data <- rgbif::name_backbone(name = nubkey_row$`Long name`)
  data$Source<-nubkey_row$Source
  data$Thematic_group<-nubkey_row$`Thematic group`
  data$ID<-nubkey_row$ID
  if(nrow(mapped_taxa)==0){
    mapped_taxa<-data
  }else{
    # check if there are missing columns in data, add them to data filled with NAs
    missing_cols_data <- setdiff(names(mapped_taxa), names(data))
    data[missing_cols_data] <- NA
    rm(missing_cols_data)
    
    # check if there are missing columns in mapped_taxa, add them to mapped_taxa filled with NAs
    missing_cols <- setdiff(names(data), names(mapped_taxa))
    mapped_taxa[missing_cols] <- NA
    rm(missing_cols)
    
    #Make sure columns are in the right order
    data <- data[, colnames(mapped_taxa)]
    
    #bind data to mapped_taxa
    mapped_taxa<-rbind(mapped_taxa,data)
  }
}

```

Export taxa that do not match with the GBIF backbone at species level.
```{r Export taxa without GBIF match}
#Filter out those that have no match with GBIF backbone
nomatch<-mapped_taxa%>%
  filter(matchType=="NONE")%>%
  select(c(ID, Thematic_group, verbatim_name,Source))

#Filter out those that have a match, but not at species level
nospeciesmatch<-mapped_taxa%>%
  filter(matchType!="NONE")%>%
  filter(is.na(speciesKey))%>%
  select(c(ID, Thematic_group, verbatim_name,Source))

# Write data to the new Google Sheets file
#ss0 <- gs4_create("longlist_no_match", sheets="Data")
#sheet_write(nomatch, ss= ss0, sheet="Data")
#ss1 <- gs4_create("longlist_no_species_match", sheets="Data")
#sheet_write(nospeciesmatch, ss = ss1, sheet="Data")

#Only keep taxa that are mapped to species level: n = 7675
mapped_species<-mapped_taxa%>%
  filter(!is.na(speciesKey))

```

```{r rematch corrected taxa}
corrected_taxa <- read_sheet("1r3DYeJ0TkMeHX50hXnPRvdm0B5KayYFqPQj749x_GLw",
                               sheet = "nomatch")
corrected_taxa<-corrected_taxa%>%
  filter(!is.na(Correction_team))
# Match taxa names with the GBIF backbone, retrieve taxon keys from GBIF when a match is found
# Initialize progress bar
pb_cor <- progress_bar$new(
 format = "\033[35m Processing [:bar] :current/:total (:percent) in :elapsed \033[0m",
  total = nrow(corrected_taxa),
  width = 60,
  clear = FALSE                  
)

correct_taxa<-data.frame()
for (i in 1:nrow(corrected_taxa)){
  pb_cor$tick()
  nubkey_row<-corrected_taxa[i,]
  data <- rgbif::name_backbone(name = nubkey_row$Correction_team)
  data$Source<-nubkey_row$Source
  data$Thematic_group<-nubkey_row$Thematic_group
  data$ID<-nubkey_row$ID
  if(nrow(correct_taxa)==0){
    correct_taxa<-data
  }else{
    # check if there are missing columns in data, add them to data filled with NAs
    missing_cols_data <- setdiff(names(correct_taxa), names(data))
    data[missing_cols_data] <- NA
    rm(missing_cols_data)
    
    # check if there are missing columns in mapped_taxa, add them to mapped_taxa filled with NAs
    missing_cols <- setdiff(names(data), names(correct_taxa))
    correct_taxa[missing_cols] <- NA
    rm(missing_cols)
    
    #Make sure columns are in the right order
    data <- data[, colnames(correct_taxa)]
    
    #bind data to mapped_taxa
    correct_taxa<-rbind(correct_taxa,data)
  }
}

stillnomatch<-correct_taxa%>%
  filter(is.na(speciesKey))

matchafterall<-correct_taxa%>%
  filter(!is.na(speciesKey))
```

Get an overview of how the data look like.
```{r get taxa overview}
table(mapped_species$kingdom)
table(mapped_species$status)
table(mapped_species$rank)
```
Looks good, but there are some synonym taxa and sub taxa levels (subspecies, variety, form) present in the data, that need to be dealt with before we can proceed to the occurrence download.

##Convert synonyms to accepted taxa 

```{r Deal with synonyms}
#For all synonyms, an acceptedUsageKey of the accepted species, subspecies, or variety is provided. These records will be mapped again against the backbone, using this acceptedUsageKey.
not_accepted<-mapped_species%>%
  filter(!is.na(acceptedUsageKey))

mapped_species<-mapped_species%>%
  filter(is.na(acceptedUsageKey))

# Initialize progress bar
pb1 <- progress_bar$new(
 format = "\033[35m Processing [:bar] :current/:total (:percent) in :elapsed \033[0m",
  total = nrow(not_accepted),
  width = 60,
  clear = FALSE                  
)

synonym_fix<-data.frame()
for (i in 1:nrow(not_accepted)){
  pb1$tick()
  data_row<-not_accepted[i,]
  backbone_data<-name_usage(key=data_row$acceptedUsageKey)$data
  backbone_data$Source<-data_row$Source
  backbone_data$Thematic_group<-data_row$Thematic_group
  backbone_data$ID<-data_row$ID
  if(nrow(synonym_fix)==0){
    synonym_fix<-backbone_data
  }else{
    # check if there are missing columns in backbone_data, add them to backbone_data filled with NAs
    missing_cols_data <- setdiff(names(synonym_fix), names(backbone_data))
    backbone_data[missing_cols_data] <- NA
    rm(missing_cols_data)
    
    # check if there are missing columns in synonym_fix, add them to synonym_fix filled with NAs
    missing_cols <- setdiff(names(backbone_data), names(synonym_fix))
    synonym_fix[missing_cols] <- NA
    rm(missing_cols)
    
    #Make sure columns are in the right order
    backbone_data <- backbone_data[, colnames(synonym_fix)]
    
    #bind data to mapped_taxa
    synonym_fix<-rbind(synonym_fix,backbone_data)
  }
}

#For all taxa, nubKey equals key, except that there are 13 for which key is valid but nubKey is NA so we'll proceed with the key column
synonym_fix<-synonym_fix%>%
  select(c(key, speciesKey, scientificName, kingdom, phylum, class, order, family, genus, rank, taxonomicStatus, Source, Thematic_group, ID )) 

mapped_species_short<-mapped_species%>%
  rename(key = "usageKey",
         taxonomicStatus = "status")%>%
  select(c(colnames(synonym_fix)))

mapped_species<-rbind(mapped_species_short, synonym_fix)
rm(mapped_species_short)
```

