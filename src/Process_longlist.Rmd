---
title: "Untitled"
author: "Soria Delva"
date: "2024-09-18"
output: html_document
---
This document describes how we arrived at a shortlist of species for the Horizon Scanning workshop, starting from a longlist of 7949 taxa.

# Setup
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Load libraries.
```{r Load libraries}
library(googlesheets4)
library(googledrive)
library(readxl)
library(dplyr)
library(rgbif)
library(progress)
library(sf)
library(rnaturalearth)
library(terra)
```

#Import data

```{r Read in data}
longlist <- read_excel("data/input/Species_long_list_Ana.xlsx")
```


#Process data

##Match initial dataset with the GBIF backbone

Match data.
```{r Match scientific names with GBIF backbone}
# Match taxa names with the GBIF backbone, retrieve taxon keys from GBIF when a match is found
# Initialize progress bar
pb <- progress_bar$new(
 format = "\033[35m Processing [:bar] :current/:total (:percent) in :elapsed \033[0m",
  total = nrow(longlist),
  width = 60,
  clear = FALSE                  
)

mapped_taxa<-data.frame()
for (i in 1:nrow(longlist)){
  pb$tick()
  nubkey_row<-longlist[i,]
  data <- rgbif::name_backbone(name = nubkey_row$`Long name`)
  data$Source<-nubkey_row$Source
  data$Thematic_group<-nubkey_row$`Thematic group`
  data$ID<-nubkey_row$ID
  if(nrow(mapped_taxa)==0){
    mapped_taxa<-data
  }else{
    # check if there are missing columns in data, add them to data filled with NAs
    missing_cols_data <- setdiff(names(mapped_taxa), names(data))
    data[missing_cols_data] <- NA
    rm(missing_cols_data)
    
    # check if there are missing columns in mapped_taxa, add them to mapped_taxa filled with NAs
    missing_cols <- setdiff(names(data), names(mapped_taxa))
    mapped_taxa[missing_cols] <- NA
    rm(missing_cols)
    
    #Make sure columns are in the right order
    data <- data[, colnames(mapped_taxa)]
    
    #bind data to mapped_taxa
    mapped_taxa<-rbind(mapped_taxa,data)
  }
}

```

Export taxa that do not match with the GBIF backbone at species level.
```{r Export taxa without GBIF match}
#Filter out those that have no match with GBIF backbone
nomatch<-mapped_taxa%>%
  filter(matchType=="NONE")%>%
  select(c(ID, Thematic_group, verbatim_name,Source))

#Filter out those that have a match, but not at species level
nospeciesmatch<-mapped_taxa%>%
  filter(matchType!="NONE")%>%
  filter(is.na(speciesKey))%>%
  select(c(ID, Thematic_group, verbatim_name,Source))

# Write data to the new Google Sheets file
#ss0 <- gs4_create("longlist_no_match", sheets="Data")
#sheet_write(nomatch, ss= ss0, sheet="Data")
#ss1 <- gs4_create("longlist_no_species_match", sheets="Data")
#sheet_write(nospeciesmatch, ss = ss1, sheet="Data")

#Only keep taxa that are mapped to species level: n = 7675
mapped_species<-mapped_taxa%>%
  filter(!is.na(speciesKey))

```

```{r rematch corrected taxa}
corrected_taxa <- read_sheet("1r3DYeJ0TkMeHX50hXnPRvdm0B5KayYFqPQj749x_GLw",
                               sheet = "nomatch")
corrected_taxa<-corrected_taxa%>%
  filter(!is.na(Correction_team))
# Match taxa names with the GBIF backbone, retrieve taxon keys from GBIF when a match is found
# Initialize progress bar
pb_cor <- progress_bar$new(
 format = "\033[35m Processing [:bar] :current/:total (:percent) in :elapsed \033[0m",
  total = nrow(corrected_taxa),
  width = 60,
  clear = FALSE                  
)

correct_taxa<-data.frame()
for (i in 1:nrow(corrected_taxa)){
  pb_cor$tick()
  nubkey_row<-corrected_taxa[i,]
  data <- rgbif::name_backbone(name = nubkey_row$Correction_team)
  data$Source<-nubkey_row$Source
  data$Thematic_group<-nubkey_row$Thematic_group
  data$ID<-nubkey_row$ID
  if(nrow(correct_taxa)==0){
    correct_taxa<-data
  }else{
    # check if there are missing columns in data, add them to data filled with NAs
    missing_cols_data <- setdiff(names(correct_taxa), names(data))
    data[missing_cols_data] <- NA
    rm(missing_cols_data)
    
    # check if there are missing columns in mapped_taxa, add them to mapped_taxa filled with NAs
    missing_cols <- setdiff(names(data), names(correct_taxa))
    correct_taxa[missing_cols] <- NA
    rm(missing_cols)
    
    #Make sure columns are in the right order
    data <- data[, colnames(correct_taxa)]
    
    #bind data to mapped_taxa
    correct_taxa<-rbind(correct_taxa,data)
  }
}

stillnomatch<-correct_taxa%>%
  filter(is.na(speciesKey))

matchafterall<-correct_taxa%>%
  filter(!is.na(speciesKey))
```

Get an overview of how the data look like.
```{r get taxa overview}
table(mapped_species$kingdom)
table(mapped_species$status)
table(mapped_species$rank)
```
Looks good, but there are some synonym taxa and sub taxa levels (subspecies, variety, form) present in the data, that need to be dealt with before we can proceed to the occurrence download.

##Convert synonyms to accepted taxa 

```{r Deal with synonyms}
#For all synonyms, an acceptedUsageKey of the accepted species, subspecies, or variety is provided. These records will be mapped again against the backbone, using this acceptedUsageKey.
not_accepted<-mapped_species%>%
  filter(!is.na(acceptedUsageKey))

mapped_species<-mapped_species%>%
  filter(is.na(acceptedUsageKey))

# Initialize progress bar
pb1 <- progress_bar$new(
 format = "\033[35m Processing [:bar] :current/:total (:percent) in :elapsed \033[0m",
  total = nrow(not_accepted),
  width = 60,
  clear = FALSE                  
)

synonym_fix<-data.frame()
for (i in 1:nrow(not_accepted)){
  pb1$tick()
  data_row<-not_accepted[i,]
  backbone_data<-name_usage(key=data_row$acceptedUsageKey)$data
  backbone_data$Source<-data_row$Source
  backbone_data$Thematic_group<-data_row$Thematic_group
  backbone_data$ID<-data_row$ID
  if(nrow(synonym_fix)==0){
    synonym_fix<-backbone_data
  }else{
    # check if there are missing columns in backbone_data, add them to backbone_data filled with NAs
    missing_cols_data <- setdiff(names(synonym_fix), names(backbone_data))
    backbone_data[missing_cols_data] <- NA
    rm(missing_cols_data)
    
    # check if there are missing columns in synonym_fix, add them to synonym_fix filled with NAs
    missing_cols <- setdiff(names(backbone_data), names(synonym_fix))
    synonym_fix[missing_cols] <- NA
    rm(missing_cols)
    
    #Make sure columns are in the right order
    backbone_data <- backbone_data[, colnames(synonym_fix)]
    
    #bind data to mapped_taxa
    synonym_fix<-rbind(synonym_fix,backbone_data)
  }
}

#For all taxa, nubKey equals key, except that there are 13 for which key is valid but nubKey is NA so we'll proceed with the key column
synonym_fix<-synonym_fix%>%
  select(c(key, speciesKey, scientificName, kingdom, phylum, class, order, family, genus, rank, taxonomicStatus, Source, Thematic_group, ID )) 

mapped_species_short<-mapped_species%>%
  rename(key = "usageKey",
         taxonomicStatus = "status")%>%
  select(c(colnames(synonym_fix)))

mapped_species<-rbind(mapped_species_short, synonym_fix)
rm(mapped_species_short)
```

##Do an upscale of accepted subspecies and varieties to their respective species level: CHECK WITH TIM WHETHER NECESSARY!!
```{r Deal with subspecies and varieties}
#Filter the taxa for which the key is not equal to the speciesKey
#These include subspecies, varieties, and synonyms that received the accepted taxonkey of an accepted variety or subspecies rather than an actual species

#Select taxa for which accepted_taxa_key does not equal the speciesKey
subspecies<-mapped_species%>%
  filter(key!=speciesKey)

#Remove these taxa from griis_all
mapped_species<-mapped_species%>%
  filter(key==speciesKey)

#Since the key will be the key of the accepted subspecies or variety, and the scientificName will be either the name of the accepted subspecies and variety, we'll need to map the speciesKey back to the GBIF backbone to get the scientificName (and accepted_taxon_name) for the accepted species. Just overwriting the key with the speciesKey will not be enough as the name will still be the wrong one (see this paragraph)

# Initialize progress bar
pb2 <- progress_bar$new(
 format = "\033[35m Processing [:bar] :current/:total (:percent) in :elapsed \033[0m",
  total = nrow(subspecies),
  width = 60,
  clear = FALSE                  
)

subspecies_fix<-data.frame()
for (i in 1:nrow(subspecies)){
  pb2$tick()
  data_row<-subspecies[i,]
  backbone_data<-name_usage(key=data_row$speciesKey)$data #Map the speciesKey back to get taxonomic info
  backbone_data$Source<-data_row$Source
  backbone_data$Thematic_group<-data_row$Thematic_group
  backbone_data$ID<-data_row$ID
  if(nrow(subspecies_fix)==0){
    subspecies_fix<-backbone_data
  }else{
    # check if there are missing columns in backbone_data, add them to backbone_data filled with NAs
    missing_cols_data <- setdiff(names(subspecies_fix), names(backbone_data))
    backbone_data[missing_cols_data] <- NA
    rm(missing_cols_data)
    
    # check if there are missing columns in subspecies_fix, add them to subspecies_fix filled with NAs
    missing_cols <- setdiff(names(backbone_data), names(subspecies_fix))
    subspecies_fix[missing_cols] <- NA
    rm(missing_cols)
    
    #Make sure columns are in the right order
    backbone_data <- backbone_data[, colnames(subspecies_fix)]
    
    #bind data to mapped_taxa
    subspecies_fix<-rbind(subspecies_fix,backbone_data)
  }
}
#all values of key are equal to nubKey
subspecies_fix<-subspecies_fix%>%
  select(c(colnames(mapped_species)))

#Bind the two dataframes back together
mapped_species<-rbind(mapped_species, subspecies_fix) #7675

#By converting synonyms, subspecies, and varieties back to the accepted species, there is a chance that the same species will occur multiple times in the list, we need to collapse first
mapped_species<-mapped_species%>%
  distinct(key, .keep_all = TRUE)%>%
  select(-c(speciesKey, taxonomicStatus,rank)) #Remove columns that we don't need anymore, all speciesKeys are equal to key, taxonomicStatus is accepted or doubtful (no more synonyms), and rank is species

```

```{r get data overview}
table(mapped_species$kingdom)
table(mapped_species$class)
```

The processed longlist contains 7288 species that can be used for downloading. From the initial 7949 records, 274 could not be matched with the GBIF backbone at species level. After converting synonyms to the accepted taxon and upscaling varieties and subspecies to their respective species level, another 387 turned out to be duplicates of an accepted species that was already present on the list.


#Download occurrence data 

##Prepare shapefile of European raster 

Read 50 x 50 km EEA raster grid

```{r Convert 50x50 EEA grid to raster}
eu_grid <- read_sf("./data/spatial/EEA_50km_grid_v2024.gpkg")
# Convert geometry to right format
eu_grid<-st_cast(eu_grid, "GEOMETRYCOLLECTION") %>% st_collection_extract("POLYGON")

##Convert the grid to a raster

eu_grid_vect <- vect(eu_grid)

# Define the resolution of the raster (50000x50000 meters)
resolution <- 50000  

# Create an empty raster with the extent, resolution, and crs
raster_template <- rast(ext(eu_grid_vect), 
                        resolution = resolution, 
                        crs = crs(eu_grid_vect))

# Rasterize the shapefile - converting polygons to a raster
# Choose the column to rasterize (cellcode)
EU_raster <- rasterize(eu_grid_vect, raster_template, field = "cellcode")

# Plot the rasterized data
mapview(EU_raster)

```

Mask rastergrid to extent of EU member states and their respective EEZ 

```{r Mask EEA raster grid and convert to shapefile}
#Create vector of EU member states
memberstates<-read.csv2(here("./data/input/GRIIS_checklists.csv"))%>%
  pull(EU_state)

#Get shapefile of EEZ of EU member states
EEZ<-st_read("./data/spatial/EEZ/EEZ_land_v2_201410.shp")%>%
  filter(Country%in% c(memberstates, "Czech Republic"))

#Explore
mapview::mapview(EEZ)

#Transform to same crs as 50x50rastergrid
EEZ<-EEZ%>%
  st_transform(., crs=st_crs(eu_grid))

#Crop raster grid to extent of EEZ shape
EEZ_ext<-terra::ext(EEZ) 

#Convert EEZ to a SpatVector that can be used for masking
EEZ_vector <- vect(EEZ) 

#Crop EU_raster to extent of EEZ
EU_raster_crop <- terra::crop(EU_raster, EEZ_ext)

#Mask cropped EU_raster with SpatVector of EEZ
EU_50raster <- terra::mask(EU_raster_crop, EEZ_vector)

#Visualize raster
mapview(EU_50raster)
#Remove objects 
rm(EEZ,EEZ_ext, EEZ_vector, EU_raster, EU_grid, EU_raster_crop)

#Store in right wkt format to feed into gbif download

```

