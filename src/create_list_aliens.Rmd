---
title: "create_list_aliens"
author: "Soria Delva"
date: "2024-09-13"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Load libraries:
```{r load_libraries, echo=FALSE}
library(dplyr)
library(readr)
library(here) 
library(rgbif)
library(progress)
library(future.apply)
```


##Import data
Get taxa from the Global Register of Introduced and Invasive Species (GRIIS) checklist for each EU member state

```{r make datasetkey list}
griis<-read.csv2(here("./data/GRIIS_checklists.csv"))
griis_list<-as.list(griis$GRIIS_checklist)
```

```{r create dataset with all griis data of eu member states}
# Initialize progress bar
pb <- progress_bar$new(
 format = "\033[37m Processing [:bar] :current/:total (:percent) in :elapsed \033[0m",
  total = total_lists,
  width = 60,
  clear = FALSE                   # Keep the bar visible after completion
)

 total_lists<-nrow(griis)
  griis_taxa<-purrr::map(seq_along(griis$GRIIS_checklist), function(x) {
    pb$tick()
    all_data<-name_usage(datasetKey = griis[x,2], limit=100000)
    country<-griis[x,1]
    taxon_data<-all_data$data%>%
      filter(origin=="SOURCE", #CHECK THIS!
             rank %in% c("SPECIES", "SUBSPECIES", "VARIETY",NA))%>% 
      select(c(nubKey,datasetKey,kingdom, phylum, order, family, scientificName,rank,taxonomicStatus))%>%
      mutate(griis_country = country)
    return(taxon_data)
  }
  )
  
griis_taxa<- do.call(rbind, griis_taxa)  # Merge the different griis taxa datasets, 32523

#Adjust weird spelling
griis_taxa <- griis_taxa %>%
  mutate(scientificName = gsub("Ã—", "×", scientificName))%>%
  mutate(scientificName = gsub("Ã©", "é", scientificName))%>%
  mutate(scientificName = gsub("í«", "ë", scientificName))%>%
  mutate(scientificName = gsub("Ã¸", "ø", scientificName))%>%
  mutate(scientificName = gsub("Ã¼", "ü", scientificName))%>%
  mutate(scientificName = gsub("Ã¶", "ö", scientificName))%>%
  mutate(scientificName = gsub("Á¨", "è", scientificName))%>%
  mutate(scientificName = gsub("Á³", "ó", scientificName))%>%
  mutate(scientificName = gsub("Ä ", "č", scientificName))%>%
  mutate(scientificName = gsub("Á¡", "á", scientificName))%>%
  mutate(scientificName = gsub("Á", "í", scientificName))%>%
  mutate(scientificName = gsub("Á", "í", scientificName))%>%
  mutate(scientificName = gsub("í ", "Á", scientificName))%>%
  mutate(scientificName = gsub("Ã", "Á", scientificName))%>%
  mutate(scientificName = case_when(scientificName == "Entyloma gaillardianum VÁ¡nky"~
                                      "Entyloma gaillardianum Vánky",
                                    scientificName == "Elodea can+D625:M626adensis Michx."~
                                      "Elodea canadensis Michx.",
                                    scientificName=="Metha spicata x suaveolens"~
                                      "Mentha spicata x suaveolens",
                                      TRUE ~ scientificName))

#NOTE: 1570 nubKeys are NA, extract nubKey based on scientificName. 3582 records do not have ACCEPTED as taxonomicStatus
```

##Add rationale to deal with missing nubKeys 
```{r deal with missing nubkeys}
#Extract all taxa that do not have an associated nubKey
nubkey_na<-griis_taxa%>%
  filter(is.na(nubKey)) %>%
  select(scientificName, griis_country, datasetKey)

#Remove these taxa from the griis_taxa dataset
griis_taxa<-griis_taxa%>%
  filter(!is.na(nubKey))

# Match taxa names with the GBIF backbone, retrieve taxon keys from GBIF when a match is found
# Initialize progress bar
pb2 <- progress_bar$new(
 format = "\033[35m Processing [:bar] :current/:total (:percent) in :elapsed \033[0m",
  total = nrow(nubkey_na),
  width = 60,
  clear = FALSE                  
)

mapped_taxa<-data.frame()
for (i in 1:nrow(nubkey_na)){
  pb2$tick()
  nubkey_row<-nubkey_na[i,]
  data <- rgbif::name_backbone(name = nubkey_row$scientificName)
  data$griis_country<-nubkey_row$griis_country
  data$datasetKey<-nubkey_row$datasetKey
  if(nrow(mapped_taxa)==0){
    mapped_taxa<-data
  }else{
    # check if there are missing columns in data, add them to data filled with NAs
    missing_cols_data <- setdiff(names(mapped_taxa), names(data))
    data[missing_cols_data] <- NA
    rm(missing_cols_data)
    
    # check if there are missing columns in mapped_taxa, add them to mapped_taxa filled with NAs
    missing_cols <- setdiff(names(data), names(mapped_taxa))
    mapped_taxa[missing_cols] <- NA
    rm(missing_cols)
    
    #Make sure columns are in the right order
    data <- data[, colnames(mapped_taxa)]
    
    #bind data to mapped_taxa
    mapped_taxa<-rbind(mapped_taxa,data)
  }
}

nomatch<-mapped_taxa%>%
  filter(matchType %in% c("NONE")) #49

#Filter on rank and select same columns as in griis_taxa
mapped_taxa<-mapped_taxa %>%
  dplyr::filter(rank %in% c("SPECIES", "SUBSPECIES", "VARIETY"))%>%
   select(c(usageKey,datasetKey,kingdom, phylum, order, family, scientificName,rank,status,griis_country))%>%
  rename(nubKey="usageKey",
         taxonomicStatus="status")

#Reorder columns so they match the order in griis_taxa
mapped_taxa<-mapped_taxa[,colnames(griis_taxa)]

#Combine datasets
griis_taxa<-rbind(griis_taxa, mapped_taxa)

#Remove objects 
remove(mapped_taxa, nubkey_na, nubkey_row)


```

##Add rationale to deal with synonyms
```{r deal with synonyms}
#Get nubkeys, match them with the gbif backbone, and compare acceptedTaxonKey with key
#If acceptedTaxonKey is provided (in the case of synonyms), this key will be stored under accepted_taxa_key, if this key is not given the key under column key will be stored here. It is necessary to run this part for all rows, and not only the synonyms.

# Initialize progress bar
pb3 <- progress_bar$new(
 format = "\033[35m Processing [:bar] :current/:total (:percent) in :elapsed \033[0m",
  total = nrow(griis_taxa),
  width = 60,
  clear = FALSE                  
)

synonym_fix<-data.frame()
for (i in 1:nrow(griis_taxa)){
  pb3$tick()
  data_row<-griis_taxa[i,]
  backbone_data<-name_usage(key=data_row$nubKey)$data
  backbone_data$griis_country<-data_row$griis_country
  backbone_data$datasetKey<-data_row$datasetKey
  if(nrow(synonym_fix)==0){
    synonym_fix<-backbone_data
  }else{
    # check if there are missing columns in backbone_data, add them to backbone_data filled with NAs
    missing_cols_data <- setdiff(names(synonym_fix), names(backbone_data))
    backbone_data[missing_cols_data] <- NA
    rm(missing_cols_data)
    
    # check if there are missing columns in synonym_fix, add them to synonym_fix filled with NAs
    missing_cols <- setdiff(names(backbone_data), names(synonym_fix))
    synonym_fix[missing_cols] <- NA
    rm(missing_cols)
    
    #Make sure columns are in the right order
    backbone_data <- backbone_data[, colnames(synonym_fix)]
    
    #bind data to mapped_taxa
    synonym_fix<-rbind(synonym_fix,backbone_data)
  }
  #if (i %% 100 == 0){
 # print(sprintf("Processed %d of %d", i, nrow(griis_taxa)))
  #}
}


griis_taxa<-synonym_fix%>%
  mutate(accepted_taxa_key = dplyr::coalesce(acceptedKey, key),
         accepted_taxon_name=dplyr::coalesce(accepted,scientificName))%>%
  select(c(accepted_taxa_key, accepted_taxon_name, datasetKey,kingdom, phylum, order, family, scientificName,rank,taxonomicStatus, griis_country))%>%
  group_by(griis_country, accepted_taxa_key) %>%
  filter(row_number() == 1) %>%  # Keeps only the first occurrence of each `accepted_taxa_key` within each country
  ungroup()

```



##Count in how many countries an alien is included on the GRIIS checklist
```{r count aliens on GRIIS checklists}
griis_overview<-griis_taxa%>%
  group_by(accepted_taxa_key, accepted_taxon_name)%>%
  summarize(n_obs = n(),
            countries = paste(unique(griis_country), collapse = ", ")) %>%
  ungroup() 

```



